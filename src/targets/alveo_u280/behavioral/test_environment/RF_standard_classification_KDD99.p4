/*
########################################################################
# THIS FILE IS PART OF Planter PROJECT
# Copyright (c) Changgang Zheng and Computing Infrastructure Group
# Department of Engineering Science, University of Oxford
# All rights reserved.
# E-mail: changgang.zheng@eng.ox.ac.uk or changgangzheng@qq.com
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at :
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#########################################################################
# This file was autogenerated

*/
/*
 * Planter
 *
 * This program implements a simple protocol. It can be carried over Ethernet
 * (Ethertype 0x1234).
 *
 * The Protocol header looks like this:
 *
 *        0                1                  2              3
 * +----------------+----------------+----------------+---------------+
 * |      P         |       4        |     Version    |     Type      |
 * +----------------+----------------+----------------+---------------+
 * |                              feature0                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature1                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature2                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature3                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature4                            |
 * +----------------+----------------+----------------+---------------+
 * |                              Result                              |
 * +----------------+----------------+----------------+---------------+
 *
 * P is an ASCII Letter 'P' (0x50)
 * 4 is an ASCII Letter '4' (0x34)
 * Version is currently 1 (0x01)
 * Type is currently 1 (0x01)
 *
 * The device receives a packet, do the classification, fills in the
 * result and sends the packet back out of the same port it came in on, while
 * swapping the source and destination addresses.
 *
 * If an unknown operation is specified or the header is not valid, the packet
 * is dropped
 */

#include <core.p4>
#include <xsa.p4>

/*************************************************************************
*********************** headers and metadata *****************************
*************************************************************************/

const bit<16> ETHERTYPE_Planter = 0x1234;
const bit<8>  Planter_P     = 0x50;   // 'P'
const bit<8>  Planter_4     = 0x34;   // '4'
const bit<8>  Planter_VER   = 0x01;   // v0.1

header ethernet_h {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header Planter_prefix_h{
    bit<8> p;
    bit<8> four;
    bit<8> ver;
    bit<8> typ;
}

header Planter_h{
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> feature4;
    bit<32> result;
}

struct header_t {
    ethernet_h   ethernet;
    Planter_prefix_h Planter_prefix;
    Planter_h    Planter;
}

struct metadata_t {
   bit<64> timestamp_ns;
   bit<16> pid;
   bit<3> ingress_port;
   bit<3> egress_port;
   bit<1> truncate_enable;
   bit<16> truncate_length;
   bit<1> rss_enable;
   bit<12> rss_entropy;
   bit<4> drop_reason;
   bit<32> scratch;
}

/*************************************************************************
*********************** Ingress Parser ***********************************
*************************************************************************/

parser SwitchParser(
    packet_in pkt,
    out header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
        ETHERTYPE_Planter : check_planter_version;
        default           : accept;
        }
    }

    state check_planter_version {
        pkt.extract(hdr.Planter_prefix);
        transition select(hdr.Planter_prefix.p,
                           hdr.Planter_prefix.four,
                           hdr.Planter_prefix.ver) {
        (Planter_P, Planter_4, Planter_VER) : parse_planter;
        default                             : accept;
        }
    }

    state parse_planter {
        pkt.extract(hdr.Planter);
        transition accept;
    }
}

/*************************************************************************
*********************** Egress Deparser *********************************
**************************************************************************/

control SwitchDeparser(
    packet_out pkt,
    in header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
*********************** Processing********************************
**************************************************************************/

control SwitchProcessing(
    inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {

    bit<13> code_f0;
    bit<12> code_f1;
    bit<21> code_f2;
    bit<16> code_f3;
    bit<5> code_f4;
    bit<7> sum_prob;
    bit<4> tree_0_vote;
    bit<4> tree_1_vote;
    bit<4> tree_2_vote;
    bit<4> tree_3_vote;
    bit<4> tree_4_vote;
    bit<7> tree_0_prob;
    bit<7> tree_1_prob;
    bit<7> tree_2_prob;
    bit<7> tree_3_prob;
    bit<7> tree_4_prob;
    bit<32>  DstAddr;
    bit<16> flag = 1;
    action drop() {
        ig_intr_md.drop=1;
    }

    action extract_feature0(out bit<13> meta_code, bit<13> tree){
        meta_code = tree;
    }

    action extract_feature1(out bit<12> meta_code, bit<12> tree){
        meta_code = tree;
    }

    action extract_feature2(out bit<21> meta_code, bit<21> tree){
        meta_code = tree;
    }

    action extract_feature3(out bit<16> meta_code, bit<16> tree){
        meta_code = tree;
    }

    action extract_feature4(out bit<5> meta_code, bit<5> tree){
        meta_code = tree;
    }

    action read_lable(bit<32> label){
        hdr.Planter.result = label;
    }

    table lookup_feature0 {
        key = { hdr.Planter.feature0:exact;}
        actions = {
            extract_feature0(code_f0);
            NoAction;
            }
        size = 41066;
        default_action = NoAction;
    }

    table lookup_feature1 {
        key = { hdr.Planter.feature1:exact;}
        actions = {
            extract_feature1(code_f1);
            NoAction;
            }
        size = 4;
        default_action = NoAction;
    }

    table lookup_feature2 {
        key = { hdr.Planter.feature2:exact;}
        actions = {
            extract_feature2(code_f2);
            NoAction;
            }
        size = 70;
        default_action = NoAction;
    }

    table lookup_feature3 {
        key = { hdr.Planter.feature3:exact;}
        actions = {
            extract_feature3(code_f3);
            NoAction;
            }
        size = 12;
        default_action = NoAction;
    }

    table lookup_feature4 {
        key = { hdr.Planter.feature4:exact;}
        actions = {
            extract_feature4(code_f4);
            NoAction;
            }
        size = 2;
        default_action = NoAction;
    }


    action read_prob0(bit<7> prob, bit<4> vote){
        tree_0_prob = prob;
        tree_0_vote = vote;
    }

    action read_prob1(bit<7> prob, bit<4> vote){
        tree_1_prob = prob;
        tree_1_vote = vote;
    }

    action read_prob2(bit<7> prob, bit<4> vote){
        tree_2_prob = prob;
        tree_2_vote = vote;
    }

    action read_prob3(bit<7> prob, bit<4> vote){
        tree_3_prob = prob;
        tree_3_vote = vote;
    }

    action read_prob4(bit<7> prob, bit<4> vote){
        tree_4_prob = prob;
        tree_4_vote = vote;
    }
    table lookup_leaf_id0 {
        key = { (bit<10>) code_f0[1:0]:exact @name("lookup_leaf_id0");
                (bit<10>) code_f1[1:0]:exact @name("lookup_leaf_id0");
                (bit<10>) code_f2[3:0]:exact @name("lookup_leaf_id0");
                (bit<10>) code_f3[3:0]:exact @name("lookup_leaf_id0");
                (bit<10>) code_f4[0:0]:exact @name("lookup_leaf_id0");
                }
        actions={read_prob0;}
        size = 100;
    }

    table lookup_leaf_id1 {
        key = { (bit<10>) code_f0[4:2]:exact @name("lookup_leaf_id1");
                (bit<10>) code_f1[4:2]:exact @name("lookup_leaf_id1");
                (bit<10>) code_f2[7:4]:exact @name("lookup_leaf_id1");
                (bit<10>) code_f3[6:4]:exact @name("lookup_leaf_id1");
                (bit<10>) code_f4[1:1]:exact @name("lookup_leaf_id1");
                }
        actions={read_prob1;}
        size = 216;
    }

    table lookup_leaf_id2 {
        key = { (bit<10>) code_f0[6:5]:exact @name("lookup_leaf_id2");
                (bit<10>) code_f1[7:5]:exact @name("lookup_leaf_id2");
                (bit<10>) code_f2[12:8]:exact @name("lookup_leaf_id2");
                (bit<10>) code_f3[8:7]:exact @name("lookup_leaf_id2");
                (bit<10>) code_f4[2:2]:exact @name("lookup_leaf_id2");
                }
        actions={read_prob2;}
        size = 108;
    }

    table lookup_leaf_id3 {
        key = { (bit<10>) code_f0[9:7]:exact @name("lookup_leaf_id3");
                (bit<10>) code_f1[9:8]:exact @name("lookup_leaf_id3");
                (bit<10>) code_f2[16:13]:exact @name("lookup_leaf_id3");
                (bit<10>) code_f3[11:9]:exact @name("lookup_leaf_id3");
                (bit<10>) code_f4[3:3]:exact @name("lookup_leaf_id3");
                }
        actions={read_prob3;}
        size = 168;
    }

    table lookup_leaf_id4 {
        key = { (bit<10>) code_f0[12:10]:exact @name("lookup_leaf_id4");
                (bit<10>) code_f1[11:10]:exact @name("lookup_leaf_id4");
                (bit<10>) code_f2[20:17]:exact @name("lookup_leaf_id4");
                (bit<10>) code_f3[15:12]:exact @name("lookup_leaf_id4");
                (bit<10>) code_f4[4:4]:exact @name("lookup_leaf_id4");
                }
        actions={read_prob4;}
        size = 180;
    }

    table decision {
        key = { tree_0_vote:exact;
                tree_1_vote:exact;
                tree_2_vote:exact;
                tree_3_vote:exact;
                tree_4_vote:exact;
                }
        actions={read_lable;}
        size = 32;
    }

    apply{
        lookup_feature0.apply();
        lookup_feature1.apply();
        lookup_feature2.apply();
        lookup_feature3.apply();
        lookup_feature4.apply();
        lookup_leaf_id0.apply();
        lookup_leaf_id1.apply();
        lookup_leaf_id2.apply();
        lookup_leaf_id3.apply();
        lookup_leaf_id4.apply();
        decision.apply();
        bit<48> tmp;
        /* Swap the MAC addresses */
        tmp = hdr.ethernet.dstAddr;
        hdr.ethernet.dstAddr = hdr.ethernet.srcAddr;
        hdr.ethernet.srcAddr = tmp;
    }
}
/*************************************************************************
***********************  S W I T C H  ************************************
*************************************************************************/

XilinxPipeline(
    SwitchParser(),
    SwitchProcessing(),
    SwitchDeparser()
) main;